class Solution:

    #Approach: 
    #Step 1: Color the graph using dfs to find out which nodes form groups(are connected)
    #Step 2: Find out the number of nodes in each group
    #Step 3: Find out to which groups the infected nodes belong to
    #Step 4: Calculate the max group size for all groups with only 1 infected node or the lowest index of infected node in case of a tie

    def minMalwareSpread(self, graph: list[list[int]], initial: list[int]) -> int:

        #edge case
        if not graph:
            return 0
        
        #create a list to maintain colors of all the nodes
        colors = [-1 for _ in range(len(graph))]

        #maintain a counter to assign new color to each group
        color = 0
        result = float('inf')

        #dfs
        def dfs(node, color):
            if colors[node] != -1:
                return
            colors[node] = color
            for i in range(len(graph)):
                if graph[node][i] == 1:
                    dfs(i, color)
        
        #use dfs to color the graph
        for i in range(len(graph)):
            if colors[i] == -1:
                dfs(i, color)
                color += 1
        
        #calculate group size
        groups = [0 for _ in range(color+1)]
        for i in range(len(colors)):
            groups[colors[i]] += 1

        #find out to which group the infected nodes belong
        groups_infected = [0 for _ in range(len(groups))]
        for i in initial:
            groups_infected[colors[i]] += 1

        #calculate the result as given in step 4 above
        for i in initial:
            if groups_infected[colors[i]] == 1:
                if result == float('inf') or groups[colors[i]] > groups[colors[result]] or groups[colors[i]] == groups[colors[result]] and result > i:
                    result = i
        
        #return result if we were able to minimize the spread or return the min of infected nodes indices
        return result if result != float('inf') else min(initial)
    
if __name__ == '__main__':
    s = Solution()
    print(s.minMalwareSpread(graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]))
        

#Time Complexity - O(V + E) : dfs
#Space Complexity - O(3V)
